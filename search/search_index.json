{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Lind-Wasm","text":"<p>Lind is a single-process sandbox that provides an option to safely execute programs. Lind executes applications using software fault isolation and a kernel microvisor to limit the potential of reaching bugs or security flaws in the application.</p> <p>In Old Norse, Old High German and Old English a \"lind\" is a shield constructed with two layers of linden wood. Linden wood shields are lightweight, and do not split easily, an appropriate metaphor for a sandboxing system which employs two technologies.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":"<ul> <li>Cage: Lightweight isolation boundary within a process<ul> <li>Can run legacy code (may need recompilation)</li> <li>Protects and isolates memory</li> </ul> </li> <li>Microvisor: Small POSIX compliant kernel within a process<ul> <li>Provides a POSIX interface</li> <li>Distinct isolation between cages</li> </ul> </li> <li>3i (three eye): Capability-based POSIX interfaces between cages</li> </ul>"},{"location":"#technology-overview","title":"Technology Overview","text":""},{"location":"#cages","title":"Cages","text":"<p>Memory and bookkeeping that encapsulates the idea of a typical OS process, encompassing applications as well as grates.</p>"},{"location":"#grates","title":"Grates","text":"<p>Can perform trusted operations on descendant cages without requiring code in the microvisor's TCB. Grates can run arbitrary code, with restrictions only placed by grates beneath them. The microvisor implements a grate with access to call into the Linux kernel.</p> <p>Inheritance Properties:</p> <ul> <li>A child inherits system calls from parent on fork</li> <li>If cage A was forked by cage B, cage A will have the same system call handlers as cage B</li> <li>If grate A was forkinterpose()'d by grate B, grate A inherits B's system call behavior changes</li> </ul>"},{"location":"#3i-system","title":"3i System","text":"<p>The 3i system serves as:</p> <ul> <li>Central point for all communication between cages</li> <li>Table container for system call routing</li> <li>Security control mechanism for system call interception</li> <li>Privilege management system for blocking unnecessary calls</li> </ul>"},{"location":"#components","title":"Components","text":""},{"location":"#wasmtime","title":"Wasmtime","text":"<p>Wasmtime is a fast and secure runtime for WebAssembly designed by Bytecode Alliance. Lind-wasm uses wasmtime as a runtime with added support for multi-processing via Asyncify.</p>"},{"location":"#lind-glibc","title":"lind-glibc","text":"<p>We\u2019ve ported glibc so that it can be compiled to wasm bytecode and linked with any wasm binary. This includes minor changes like replacing assembly code, and add a mechansim to transfer system calls to the trusted runtime and microvisor.</p>"},{"location":"#rawposix","title":"RawPOSIX","text":"<p>Provides normal POSIX system calls including:</p> <ul> <li>Signals</li> <li>Fork/exec</li> <li>Threading</li> <li>File system</li> <li>Networking</li> <li>Separate handling of cages' fds and threads</li> </ul>"},{"location":"#3i-implementation","title":"3i Implementation","text":"<p>The iPC (intra-process call) interposable interface enables secure and efficient cage communication with function call-like speed. It provides POSIX interfaces between cages with interposition capabilities, enabling fine-grained security and access control while maintaining program behavior.</p>"},{"location":"build/bazel/","title":"Bazel","text":"<p>New Build System (Bazel):</p> <p>install bazel on your system: bazel</p> <pre><code>bazel build //:make_all\nbazel build //:make_wasmtime\n</code></pre>"},{"location":"build/build-libc/","title":"Building glibc to WASM","text":"<p>I'd recommend reading this doc in its entirety before trying to compile.</p>"},{"location":"build/build-libc/#prerequisites","title":"Prerequisites","text":"<p>You need to have an access to the server, ask somebody to help you. Then you pull an image to docker and run it</p> <pre><code>docker pull ubuntu:22.04\ndocker run -it ubuntu\n</code></pre> <p>Update apt and apt-get </p> <pre><code>cd home\napt-get update\napt update\n</code></pre> <p>we should install some apt essential</p> <pre><code>apt install build-essential\napt install git\napt install wget\napt install gcc-i686-linux-gnu g++-i686-linux-gnu\napt install nano\napt install bison\napt install gawk\napt install vim\napt install libxml2\napt install python3 (2.America 105.New York)\n</code></pre> <p>We need glibc from lind-wasm, if you did it already then ignore it https://github.com/Lind-Project/lind-wasm.git</p> <p>We need WASM compatible <code>clang</code> and <code>ar</code>, which can be built locally from <code>wasi-sdk</code> https://github.com/WebAssembly/wasi-sdk</p> <p>Also strongly recommend to install <code>wasm-objdump</code> from the <code>wabt</code> toolkit https://github.com/WebAssembly/wabt</p> <p>If you want to download files from github to server use <code>git clone</code> and <code>recurse-submodules</code>deal with repositories that contain submodules</p> <pre><code>git clone --recurse-submodules\n</code></pre> <p>If any error said \"permission denied\" then just add \"sudo\" at the front of the command line.</p> <p>If you want to edit file through terminal, try to search vim and study how to use it.</p>"},{"location":"build/build-libc/#two-ways-to-install-complier","title":"Two ways to install complier","text":"<ol> <li>Download <code>clang-16</code> and add some file(I recommend using this way, and I will use clang-16 as example for explanation)</li> <li>Git clone wasi-sdk and use the <code>clang-18</code> in wasi-sdk, you need to compile wasi-sdk before using it</li> </ol>"},{"location":"build/build-libc/#install-clang-16recommended-way","title":"Install clang-16(recommended way)","text":"<p>Download <code>clang-16</code> from this link</p> <pre><code>wget https://github.com/llvm/llvm-project/releases/download/llvmorg-16.0.4/clang+llvm-16.0.4-x86_64-linux-gnu-ubuntu-22.04.tar.xz\n</code></pre> <p>Unzip clang+llvm-16.0.4-x86_64-linux-gnu-ubuntu-22.04.tar.xz</p> <pre><code>tar -xf clang+llvm-16.0.4-x86_64-linux-gnu-ubuntu-22.04.tar.xz\n</code></pre> <p>Switch branch of glibc(cd to lind-wasm/glibc). Find out which branch you are on currently and switch to branch \"main\" </p> <pre><code>cd /home/lind-wasm/glibc\ngit branch -a\ngit switch main \n</code></pre> <p>We move <code>libclang_rt.builtins-wasm32.a</code> from <code>/home/lind-wasm/glibc/wasi</code> to <code>/home/clang+llvm-16.0.4-x86_64-linux-gnu-ubuntu-22.04/lib/clang/16/lib/</code> using</p> <pre><code>cd /home\nmv /home/lind-wasm/glibc/wasi /home/clang+llvm-16.0.4-x86_64-linux-gnu-ubuntu-22.04/lib/clang/16/lib\n</code></pre>"},{"location":"build/build-libc/#compile-wasi-sdknot-available-now","title":"Compile wasi-sdk(not available now)","text":"<p>I assume you already git clone wasi-sdk, now you need to cd to wasi-sdk and run these code</p> <pre><code>cmake -G Ninja -B build/toolchain -S . -DWASI_SDK_BUILD_TOOLCHAIN=ON -DCMAKE_INSTALL_PREFIX=build/install\n\ncmake --build build/toolchain --target install\n\ncmake -G Ninja -B build/sysroot -S . \\\n    -DCMAKE_INSTALL_PREFIX=build/install \\\n    -DCMAKE_TOOLCHAIN_FILE=build/install/share/cmake/wasi-sdk.cmake \\\n    -DCMAKE_C_COMPILER_WORKS=ON \\\n    -DCMAKE_CXX_COMPILER_WORKS=ON\ncmake --build build/sysroot --target install\n</code></pre>"},{"location":"build/build-libc/#configure","title":"Configure","text":"<p>We create a .sh file and write a config script in the file. We use <code>nano</code> to create file in the glibc root directory(glibc is in the lind-wasm directory) and you can change <code>anyname</code> into the filename you want</p> <pre><code>cd /home/lind-wasm/glibc\nnano anyname.sh\n</code></pre> <p>then we write the script like this</p> <pre><code>#!/bin/bash\nset -e\nBUILDDIR=build\nmkdir -p $BUILDDIR\ncd $BUILDDIR\n../configure --disable-werror --disable-hidden-plt --with-headers=/usr/i686-linux-gnu/include --prefix=/home/lind-wasm/glibc/target --host=i686-linux-gnu --build=i686-linux-gnu\\\n    CFLAGS=\" -O2 -g\" \\\n    CC=\"/home/clang+llvm-16.0.4-x86_64-linux-gnu-ubuntu-22.04/bin/clang-16 --target=wasm32-unkown-wasi -v -Wno-int-conversion\"\n</code></pre> <p>You should replace <code>CC</code> to the path to your <code>clang</code>, this path should work but if not change this part <code>/home/clang+llvm-16.0.4-x86_64-linux-gnu-ubuntu-22.04/bin/clang-16</code> into your own path. If you define <code>BUILDDIR=build</code>, then the compiled WASM object files will appear under <code>glibc/build</code>. Be aware that you should make sure this build directory is empty before running config script, so you need to <code>rm -rf build</code> to remove all the things inside build directory before recompiling it.</p> <p>A crutial job of the configure script is deciding which sysdeps directories to use according to the <code>host</code> and <code>build</code> string. We already changed the configure script in glibc root directory, and the lind add-on directories are already baked to be included.</p> <p>The configure flags we need:</p> <ul> <li><code>disable-werror</code>: we have countless warnings, so we ignore them for now</li> <li><code>disable-hidden-plt</code>: PLT bypassing optimization is causing ~50k errors, simply disable it for now</li> <li><code>with-headers</code>: glibc requires Linux kernel headers to be installed before config and compile, so set this flag to a built-in sysroot of 32bit, this doesn't seem to raise an issue for our WASM built</li> <li><code>prefix=</code>: this is the path of the generated sysroot when you use <code>make install</code>. But note that, the glibc's <code>make install</code> will NOT work at all for WASM, because WASM sysroot has differen structure convention, also requires an <code>llvm-ar</code> arhive. More details, see my script <code>gen_sysroot.sh</code>. However, we can still use <code>make install</code> just to generate the <code>.h</code> files of the sysroot</li> <li><code>host</code> &amp; <code>target</code>: we start off from the sysdeps direcotries of i686, so fixing these options</li> </ul> <p>The compiler flags we need:</p> <ul> <li><code>-O2 -g</code>: nah the glibc won't allow you to compile with <code>O0</code>, so we bear with this <code>O2</code> optimization during debugging. But sometimes you can change to <code>O1</code>.</li> <li><code>-Wno-int-conversion</code>: we disable int conversion warnings, cuz all 32bit types as WASM function arguments, are eventually i32 anyway</li> <li><code>--target=wasm32-unkown-wasi</code>: this tells the compiler we want to compile to WASM</li> </ul> <p>Now the last step is to run the .sh file</p> <pre><code>sudo chmod +x anyname.sh \n./anyname.sh\n</code></pre> <p>After config succeed, you will see these in the <code>build</code> directory,</p> <pre><code>Makefile  bits  config.h  config.log  config.make  config.status\n</code></pre>"},{"location":"build/build-libc/#compiling-to-object-files","title":"Compiling to object files","text":"<p>In the build directory, usually we use <code>make --keep-going -j4</code>. The first flag is to continue compiling after errors, we need this cuz there are too many errors now (mainly due to assembly about threading). The <code>-j</code> is important to speed it up, but also makes the compilation log interleaved. The compilation log is VERY IMPORTANT, which tells why a given c file failed to be compiled. So sometimes we don't want the <code>-j</code>. Also, we can copy the actual compiler command in the compile log. For such commands, if we want to compile a single C file, only the source file path need to be further specified. We can use this to test compiling a specific file.</p> <pre><code>cd build\nmake --keep-going -j4\n</code></pre>"},{"location":"build/build-libc/#installing-glibc","title":"Installing glibc","text":"<p>We need to install the glibc we complied to the prefix in the .sh file. For example, mine will install into <code>target</code>. This is the install command line we need to use</p> <pre><code>make install --keep-going\n</code></pre>"},{"location":"build/build-libc/#generating-wasm-sysroot","title":"Generating WASM sysroot","text":"<p>Back to glibc</p> <pre><code>cd ..\n</code></pre> <p>This is an example for <code>gen_sysroot.sh</code></p> <pre><code>#!/bin/bash\n\n# Define the source directory for object files (change ./build to your desired path)\nsrc_dir=\"./build\"\n\n# Define paths for copying additional resources\ninclude_source_dir=\"/home/lind-wasm/glibc/target/include\"\ncrt1_source_path=\"/home/lind-wasm/glibc/lind_syscall/crt1.o\"\nlind_syscall_path=\"/home/lind-wasm/glibc/lind_syscall/lind_syscall.o\" # Path to the lind_syscall.o file\n\n# Define the output archive and sysroot directory\noutput_archive=\"sysroot/lib/wasm32-wasi/libc.a\"\nsysroot_dir=\"sysroot\"\n\n# First, remove the existing sysroot directory to start cleanly\nrm -rf \"$sysroot_dir\"\n\n# Find all .o files recursively in the source directory, ignoring stamp.o\nobject_files=$(find \"$src_dir\" -type f -name \"*.o\" ! \\( -name \"stamp.o\" -o -name \"argp-pvh.o\" -o -name \"repertoire.o\" \\))\n\n# Add the lind_syscall.o file to the list of object files\nobject_files=\"$object_files $lind_syscall_path\"\n\n# Check if object files were found\nif [ -z \"$object_files\" ]; then\n  echo \"No suitable .o files found in '$src_dir'.\"\n  exit 1\nfi\n\n# Create the sysroot directory structure\nmkdir -p \"$sysroot_dir/include/wasm32-wasi\" \"$sysroot_dir/lib/wasm32-wasi\"\n\n# Pack all found .o files into a single .a archive\n/home/clang+llvm-16.0.4-x86_64-linux-gnu-ubuntu-22.04/bin/llvm-ar rcs \"$output_archive\" $object_files\n\n# Check if llvm-ar succeeded\nif [ $? -eq 0 ]; then\n  echo \"Successfully created $output_archive with the following .o files:\"\n  echo \"$object_files\"\nelse\n  echo \"Failed to create the archive.\"\n  exit 1\nfi\n\n# Copy all files from the external include directory to the new sysroot include directory\ncp -r \"$include_source_dir\"/* \"$sysroot_dir/include/wasm32-wasi/\"\n\n# Copy the crt1.o file into the new sysroot lib directory\ncp \"$crt1_source_path\" \"$sysroot_dir/lib/wasm32-wasi/\"\n</code></pre> <p>Here are some macros we need to twist:</p> <ul> <li><code>src_dir</code>: the glibc <code>build</code> directory that contains all the WASM object files</li> <li><code>include_source_dir</code>: the path to your pre-built headers</li> <li><code>crt1_source_path</code>: path to your pre-built crt1.o</li> <li><code>lind_syscall_path</code>: you also need to pre-compile <code>lind_syscall.o</code>, just like <code>crt1.o</code>, and the source file is under glibc/lind_syscall</li> <li><code>sysroot_dir</code>: path to generate the sysroot at</li> <li><code>output_archive</code>: the path to the generate the libc.a, should be align with <code>sysroot_dir</code></li> </ul> <p>Note that the header files should be pre-generated using <code>make install</code>. The crt1.o should be pre-compiled from this simple C file (see the WASM compile doc as well). The main job of this script is to change <code>include_source_dir</code>(path to target file), <code>crt1_source_path</code>(path to crt1.o), <code>lind_syscall_path</code>(path to lind_syscall.o), and <code>Pack all found .o files into a single .a archive</code>(path to llvm-ar) into your own path. crt1.o and lind_syscall.o are in <code>lind_syscall</code> directory in glibc.</p> <p>After modifying all the path talked on the above, try to run <code>gen_sysroot.sh</code> and see if it works</p> <pre><code>chmod +x gen_sysroot.sh\n./gen_sysroot.sh\n</code></pre> <p>This procedure is specified in the <code>gen_sysroot.sh</code> script in our glibc repo. It's main job is to generate a WASM sysroot structre like</p> <pre><code>sysroot/\n- include/\n  - wasm32-wasi/\n    - stdio.h\n    - ...other headers\n- lib/\n  - wasm32-wasi/\n    - crt1.o\n    - libc.a\n</code></pre>"},{"location":"build/build-rawposix/","title":"Building safeposix-rust","text":""},{"location":"build/build-rawposix/#setting-environment","title":"Setting environment","text":"<p>We need to set environment with the following codes</p> <pre><code>cd /home\napt update\napt install git\napt install curl\napt install gcc\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs/ | sh\nrustup install nightly\n. \"$HOME/.cargo/env\"\nrustup default nightly\n</code></pre>"},{"location":"build/build-rawposix/#clone-git-repo","title":"Clone git repo","text":"<p>First we need to clone the mono-repo:</p> <pre><code>git clone https://github.com/Lind-Project/lind-wasm.git\n</code></pre> <p>Then, go the <code>RawPOSIX</code> directory:</p> <pre><code>cd lind-wasm/src/RawPOSIX\n</code></pre>"},{"location":"build/build-rawposix/#build","title":"Build","text":"<p>Compile and make sure there are librustposix.so</p> <pre><code>cargo build\n</code></pre>"},{"location":"build/build-wasmtime/","title":"Building Wasmtime","text":""},{"location":"build/build-wasmtime/#prerequisites","title":"Prerequisites","text":""},{"location":"build/build-wasmtime/#location","title":"location","text":"<p>Just be aware Wasmtime is in the lind-wasm directory.</p>"},{"location":"build/build-wasmtime/#git-submodules","title":"Git Submodules","text":"<p>The Wasmtime repository contains a number of git submodules. To build Wasmtime and most other crates in the repository, ensure that these are initialized with the following command:</p> <pre><code>cd /home/lind-wasm/wasmtime\ngit submodule update --init\n</code></pre>"},{"location":"build/build-wasmtime/#switch-branch","title":"Switch branch","text":"<p>switch branch to add-lind</p> <pre><code>git switch add-lind\n</code></pre>"},{"location":"build/build-wasmtime/#the-rust-toolchain","title":"The Rust Toolchain","text":"<p>You should have these tools, if not install the Rust toolchain, which includes <code>rustup</code>, <code>cargo</code>, <code>rustc</code>, etc. You can find the installation instructions here.</p>"},{"location":"build/build-wasmtime/#libclang-optional","title":"libclang (Optional)","text":"<p>The <code>wasmtime-fuzzing</code> crate transitively depends on <code>bindgen</code>, which requires <code>libclang</code> to be installed on your system. If you want to work on Wasmtime's fuzzing infrastructure, you'll need <code>libclang</code>. Details on how to get <code>libclang</code> and make it available for <code>bindgen</code> are here.</p>"},{"location":"build/build-wasmtime/#building-the-wasmtime-cli","title":"Building the Wasmtime CLI","text":"<pre><code>cd /home/lind-wasm/wasmtime/crates/rustposix/src\n</code></pre> <p>Cd to path <code>/home/lind-wasm/wasmtime/crates/rustposix/src</code> and vim file <code>build.rs</code> change the first line into <code>cargo:rustc-link-search=native=/home/lind-wasm/wasmtime/crates/rustposix</code></p> <pre><code>vim build.rs\n</code></pre> <pre><code>cd /home/lind-wasm/wasmtime\n</code></pre> <p>Remember to export</p> <pre><code>export LD_LIBRARY_PATH=/home/lind-wasm/wasmtime/crates/rustposix:$LD_LIBRARY_PATH\n</code></pre> <p>You should find librustposix.so in rustposix(...wasmtime/crates/rustposix), but instead we should replace librustposix.so with another librustposix.so located in the safeposix-rust you complied before. Use the code below, you can change <code>librustposix.so</code> with the name of the file you want to replace and change <code>/home/lind-wasm/wasmtime/crates/rustposix</code> with the path of the new file(for file use cp for directory use cp -r )</p> <pre><code>cp /home/safeposix-rust/target/debug/librustposix.so /home/lind-wasm/wasmtime/crates/rustposix\n</code></pre> <p>To make an unoptimized, debug build of the Wasmtime CLI tool, go to the root of the repository and run:</p> <pre><code>cargo build\n</code></pre> <p>The built executable will be located at <code>target/debug/wasmtime</code>.</p> <p>To make an optimized build, run the following command in the root of the repository:</p> <pre><code>cargo build --release\n</code></pre> <p>The built executable will be located at <code>target/release/wasmtime</code>.</p> <p>You can also build and run a local Wasmtime CLI by replacing <code>cargo build</code> with <code>cargo run</code>.</p> <p>Additional Instructions:</p> <p>First you need to download lind-wasm in your docker to home directory</p> <pre><code>sudo git clone https://github.com/Lind-Project/lind-wasm.git\n</code></pre> <p>I assume you have rust else use</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs/ | sh\nrustup install nightly\n. \"$HOME/.cargo/env\"\nrustup default nightly\n</code></pre> <p>set Clang path</p> <pre><code>wget https://github.com/llvm/llvm-project/releases/download/llvmorg-16.0.4/clang+llvm-16.0.4-x86_64-linux-gnu-ubuntu-22.04.tar.xz\ntar -xf clang+llvm-16.0.4-x86_64-linux-gnu-ubuntu-22.04.tar.xz\nexport CLANG=clang_folder\n</code></pre> <pre><code>cd lind-wasm\nmv ./src/glibc/wasi $CLANG/lib/clang/16/lib\n./lindtool.sh make_all\n./lindtool.sh compile_wasmtime\n</code></pre>"},{"location":"community/","title":"Community","text":"<p>Join #lind on the NYU Secure Systems Lab Slack to receive updates about the project and upcoming events, or dial in on a community meeting! Details are listed below and on Google Calendar.</p>"},{"location":"community/#meetings","title":"Meetings","text":""},{"location":"community/#governance-committee","title":"Governance Committee","text":"<ul> <li>Weekly on Friday 15:00 - 16:00 ET</li> <li>Zoom</li> <li>Meeting notes</li> </ul>"},{"location":"community/#tech-talks","title":"Tech Talks","text":"<ul> <li>Every 2 weeks on Friday 13:00 - 14:00 ET</li> <li>Zoom</li> <li>Meeting notes</li> </ul>"},{"location":"community/#maintainers-evaluation-benchmarking-wg","title":"Maintainers, Evaluation, &amp; Benchmarking WG","text":"<ul> <li>Every 2 weeks on Thursday 13:00 - 14:00 ET</li> <li>Zoom</li> <li>Meeting notes</li> </ul>"},{"location":"community/conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"community/conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"community/conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"community/conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"community/conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"community/conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at lind-project-reporting@googlegroups.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"community/conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"community/conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"community/conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"community/conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"community/conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"community/conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"community/team/","title":"Lind-WASM Team","text":""},{"location":"community/team/#advisor","title":"Advisor","text":"Justin Cappos   Professor, NYU"},{"location":"community/team/#maintainers","title":"Maintainers","text":"Nick Renner   PhD Candidate, NYU  Yuchen (Dennis) Zhang   Post-doctoral researcher, NYU  Yaxuan (Alice) Wen    PhD Student, NYU  Qianxi Chen   Undergraduate Research Lead, NYU"},{"location":"contribute/","title":"Contributing","text":"<p>The Lind sandbox is developed in the lind-wasm monorepo on GitHub. You can find the documentation assets, including this site, in lind-wasm-docs. Please contribute to the Lind project by submitting issues or pull requests to these repositories.</p> <p>To report a security issue, please refer to the Security Policy!</p> <p>Detailed guidelines about writing code, tests, documentation, and more are below:</p> <ul> <li>Rust Style Guide</li> <li>Unit Tests</li> <li>Adding to the docs</li> <li>Security Policy</li> <li>Code of Conduct</li> </ul>"},{"location":"contribute/security/","title":"Security Issues and Bugs","text":"<p>Security issues can be reported to maintainers privately via GitHub:</p> <ul> <li>Report new vulnerability</li> </ul> <p>Please do not use the GitHub issue tracker to submit vulnerability reports. The issue tracker is intended for bug reports and to make feature requests.</p>"},{"location":"contribute/styleguide/","title":"Rust Style Guide","text":""},{"location":"contribute/styleguide/#1-introduction","title":"1. Introduction","text":"<p>This style guide establishes conventions for writing Rust code that is clear, maintainable, and consistent. It is inspired by the principles outlined in the Tcl/Tk Engineering Manual and adapts them to the unique features of Rust.</p>"},{"location":"contribute/styleguide/#2-code-structure-and-organization","title":"2. Code Structure and Organization","text":""},{"location":"contribute/styleguide/#21-project-structure","title":"2.1 Project Structure","text":"<ul> <li>Modules: Organize code into modules (<code>mod</code>) to group related functionality.</li> <li>File Structure: Keep each module in its own file where possible. Use a directory structure for nested modules.</li> <li>Naming Conventions:</li> <li>Filenames: Use <code>snake_case</code> (e.g., <code>data_processing.rs</code>).</li> <li>Module names: Use <code>snake_case</code> (e.g., <code>data_processing</code>).</li> </ul>"},{"location":"contribute/styleguide/#22-code-layout","title":"2.2 Code Layout","text":"<ul> <li>Limit lines to 80\u2013100 characters for readability.</li> <li>Use 4 spaces per indentation level.</li> <li>Separate logical blocks of code with one blank line.</li> <li>Group related constants, type definitions, and functions together.</li> </ul>"},{"location":"contribute/styleguide/#23-comments","title":"2.3 Comments","text":"<ul> <li>File Headers: Begin each file with a brief comment summarizing its purpose.   List the following:</li> <li><code># Arguments</code> \u2013 Lists function parameters and their descriptions.  </li> <li><code># Returns</code> \u2013 Describes the return value and its type.  </li> <li><code># Panics</code> \u2013 Explains when and why the function may panic.  </li> <li><code># Examples</code> \u2013 Provides usage examples in Rust code blocks.  </li> <li><code># Safety</code> \u2013 Used for <code>unsafe</code> functions, outlining preconditions.  </li> </ul> <p>Example:</p> <pre><code>/// Computes the area of a rectangle.\n///\n/// # Arguments\n///\n/// * `width` - The width of the rectangle.\n/// * `height` - The height of the rectangle.\n///\n/// # Returns\n///\n/// The computed area as `f64`.\n///\n/// # Panics\n///\n/// This function does not explicitly handle negative values.\n///\n/// # Examples\n///\n/// ```\n/// let area = my_crate::calculate_area(2.0, 3.0);\n/// assert_eq!(area, 6.0);\n/// ```\nfn calculate_area(width: f64, height: f64) -&gt; f64 {\n    width * height\n}\n\n</code></pre> <ul> <li>Module and Function Documentation:</li> <li>Use <code>///</code> for public items.</li> <li>Use <code>//!</code> for module-level documentation.</li> </ul> <p>Example:</p> <pre><code>//! # Geometry Module\n//!\n//! This module provides functions for calculating areas of geometric shapes.\n//!\n//! # Examples\n//!\n//! ```\n//! use crate::geometry::calculate_area;\n//!\n//! let area = calculate_area(5.0, 4.0);\n//! assert_eq!(area, 20.0);\n//! ```\n</code></pre> <ul> <li>Inline Comments: Use <code>//</code> sparingly for explanations within code blocks.</li> </ul>"},{"location":"contribute/styleguide/#3-naming-conventions","title":"3. Naming Conventions","text":""},{"location":"contribute/styleguide/#31-general-guidelines","title":"3.1 General Guidelines","text":"<ul> <li>Use descriptive names for variables, functions, and types.</li> <li>Avoid abbreviations unless they are well-known.</li> <li>Be consistent in naming patterns across similar components.</li> </ul>"},{"location":"contribute/styleguide/#32-specific-guidelines","title":"3.2 Specific Guidelines","text":"<ul> <li>Constants: Use <code>UPPER_SNAKE_CASE</code>.</li> <li>Variables: Use <code>snake_case</code>.</li> <li>Functions: Use <code>snake_case</code>.</li> <li>Structs and Enums: Use <code>PascalCase</code>.</li> <li>Traits: Use <code>PascalCase</code> with meaningful names (e.g., <code>Display</code>, <code>Serializable</code>).</li> <li>Lifetimes: Use short, single-letter names (e.g., <code>'a</code>, <code>'b</code>) for common cases.</li> </ul>"},{"location":"contribute/styleguide/#4-coding-practices","title":"4. Coding Practices","text":""},{"location":"contribute/styleguide/#41-functions","title":"4.1 Functions","text":"<ul> <li>Functions should have a single responsibility.</li> <li>Use early returns to reduce nesting.</li> <li>Use meaningful parameter names to describe their purpose.</li> </ul> <pre><code>fn calculate_area(width: f32, height: f32) -&gt; f32 {\n    width * height\n}\n</code></pre>"},{"location":"contribute/styleguide/#42-error-handling","title":"4.2 Error Handling","text":"<ul> <li>Use <code>Result</code> and <code>Option</code> for error handling.</li> <li>Prefer <code>?</code> syntax for propagating errors.</li> <li>Include detailed context in errors using crates like <code>thiserror</code> or <code>anyhow</code>.</li> </ul>"},{"location":"contribute/styleguide/#43-ownership-and-borrowing","title":"4.3 Ownership and Borrowing","text":"<ul> <li>Favor borrowing over cloning or moving unless ownership is required.</li> <li>Explicitly document the ownership model in complex cases.</li> </ul>"},{"location":"contribute/styleguide/#44-iterators-and-collections","title":"4.4 Iterators and Collections","text":"<ul> <li>Use iterators for collection processing instead of manual loops.</li> <li>Use expressive iterator combinators like <code>map</code>, <code>filter</code>, and <code>fold</code>.</li> </ul> <pre><code>let squares: Vec&lt;i32&gt; = numbers.iter().map(|n| n * n).collect();\n</code></pre>"},{"location":"contribute/styleguide/#5-style-and-formatting","title":"5. Style and Formatting","text":""},{"location":"contribute/styleguide/#51-use-of-rustfmt","title":"5.1 Use of <code>rustfmt</code>","text":"<ul> <li>Use <code>rustfmt</code> to automatically format code.</li> <li>Configure <code>rustfmt</code> in <code>rustfmt.toml</code> for project-specific preferences.</li> </ul>"},{"location":"contribute/styleguide/#52-imports","title":"5.2 Imports","text":"<ul> <li>Group <code>use</code> statements:</li> <li>Standard library imports first.</li> <li>External crate imports second.</li> <li>Internal module imports last.</li> </ul> <pre><code>use std::collections::HashMap;\nuse serde::Serialize;\nuse crate::utils::parse_data;\n</code></pre>"},{"location":"contribute/styleguide/#53-attributes","title":"5.3 Attributes","text":"<ul> <li>Place attributes (<code>#[derive]</code>, <code>#[test]</code>, etc.) on the line immediately above the item.</li> <li>Use multi-line formatting for attributes with multiple arguments.</li> </ul> <pre><code>#[derive(Debug, Clone, PartialEq)]\nstruct Point {\n    x: f32,\n    y: f32,\n}\n</code></pre>"},{"location":"contribute/styleguide/#6-testing","title":"6. Testing","text":""},{"location":"contribute/styleguide/#61-unit-tests","title":"6.1 Unit Tests","text":"<ul> <li>Write unit tests for all public functions.</li> <li>Place tests in a <code>mod tests</code> block within the same file.</li> <li>Whenever possible, include doctests as mentioned in the rust style guide</li> </ul> <pre><code>/// Computes the area of a rectangle.\n///\n/// # Examples\n///\n/// ```\n/// let area = my_crate::calculate_area(2.0, 3.0);\n/// assert_eq!(area, 6.0);\n/// ```  \nfn calculate_area(width: f64, height: f64) -&gt; f64 {\n    width * height\n}\n\n</code></pre>"},{"location":"contribute/styleguide/#62-integration-tests","title":"6.2 Integration Tests","text":"<ul> <li>Place integration tests in the <code>tests/</code> directory.</li> <li>Use descriptive filenames and group related tests together.</li> </ul>"},{"location":"contribute/styleguide/#63-test-coverage","title":"6.3 Test Coverage","text":"<ul> <li>Aim for high test coverage but prioritize testing critical paths.</li> </ul>"},{"location":"contribute/styleguide/#7-unsafe-code","title":"7. Unsafe Code","text":"<ul> <li>As mentioned in commenting style above, ensure unsafe functions are documented with a <code># Safety</code> block</li> <li>Use <code>unsafe</code> sparingly and only when absolutely necessary.</li> <li>Encapsulate unsafe code in functions with clear and well-documented safety contracts.</li> </ul> <pre><code>/// Dereferences a raw pointer.\n///\n/// # Safety\n///\n/// - The caller must ensure that `ptr` is non-null and properly aligned.\n/// - Accessing the pointer must not cause a data race.\n///\n/// # Examples\n///\n/// ```\n/// let x = 42;\n/// let ptr = &amp;x as *const i32;\n/// unsafe {\n///     assert_eq!(deref_raw_pointer(ptr), 42);\n/// }\n/// ```\nunsafe fn deref_raw_pointer(ptr: *const i32) -&gt; i32 {\n    *ptr\n}\n\n</code></pre>"},{"location":"contribute/styleguide/#8-documentation","title":"8. Documentation","text":""},{"location":"contribute/styleguide/#81-public-api-documentation","title":"8.1 Public API Documentation","text":"<ul> <li>Use <code>///</code> comments to document all public types, traits, and functions.</li> <li>Include examples in the documentation when possible.</li> </ul> <pre><code>/// Calculates the area of a rectangle.\n///\n/// # Arguments:\n///\n/// * `width` - The width of the rectangle.\n/// * `height` - The height of the rectangle.\n///\n/// # Examples:\n///\n/// ```\n/// let area = calculate_area(2.0, 3.0);\n/// assert_eq!(area, 6.0);\n/// ```\nfn calculate_area(width: f32, height: f32) -&gt; f32 {\n    width * height\n}\n</code></pre>"},{"location":"contribute/styleguide/#82-internal-documentation","title":"8.2 Internal Documentation","text":"<ul> <li>Use inline comments (<code>//</code>) to explain complex or non-obvious code.</li> <li>Avoid redundant comments that restate obvious code behavior.</li> </ul>"},{"location":"contribute/styleguide/#9-dependencies","title":"9. Dependencies","text":"<ul> <li>Use dependencies sparingly and prefer well-maintained and widely-used crates.</li> <li>Regularly audit dependencies for vulnerabilities and updates.</li> <li>Pin versions in the <code>Cargo.toml</code> to ensure reproducibility.</li> </ul>"},{"location":"contribute/styleguide/#10-performance-and-optimization","title":"10. Performance and Optimization","text":"<ul> <li>Write clear, maintainable code first; optimize only after profiling.</li> <li>Use Rust's powerful profiling tools (e.g., <code>cargo-flamegraph</code>).</li> <li>Avoid premature optimization that sacrifices code readability.</li> </ul>"},{"location":"contribute/styleguide/#11-community-standards","title":"11. Community Standards","text":"<ul> <li>Follow the Rust API Guidelines.</li> <li>Participate in code reviews and encourage constructive feedback.</li> <li>Contribute back to the Rust ecosystem by reporting bugs and submitting patches.</li> </ul>"},{"location":"contribute/styleguide/#12-conclusion","title":"12. Conclusion","text":"<p>Adhering to this style guide will ensure that Rust codebases remain consistent, maintainable, and aligned with the language's best practices. Regularly revisit and refine these guidelines to adapt to new developments in the Rust ecosystem.</p>"},{"location":"contribute/unit-tests/","title":"Unit tests","text":"Commands Short Commands Description Example Usage singlecompile <code>sc</code> Compile a single <code>.c</code> file to <code>.wasm</code> and <code>.cwasm</code>. <code>./wasmtest.sh sc file.c</code> singlerun <code>sr</code> Run a single previously compiled <code>.wasm</code>/<code>.cwasm</code>file. <code>./wasmtest.sh sr file.c</code> single <code>s</code> Compile and run a single <code>.c</code> file in sequence (first compile to WASM, then run). <code>./wasmtest.sh s file.c</code> allcompile <code>ac</code> Compile all <code>.c</code> test files in <code>$LIND_WASM_BASE/tests/unit-tests</code>. <code>./wasmtest.sh ac</code> allrun <code>ar</code> Run all compiled tests in <code>$LIND_WASM_BASE/tests/unit-tests</code>. <code>./wasmtest.sh ar</code> all <code>a</code> Compile and run all test files in <code>$LIND_WASM_BASE/tests/unit-tests</code>. <code>./wasmtest.sh a</code> filescompile, filecompile <code>fc</code> Compile test files listed in a user-provided text file (each line should contain one <code>.c</code> filename). <code>./wasmtest.sh fc filelist.txt</code> filesrun, filerun <code>fr</code> Run test files listed in a user-provided text file (assumes the <code>.wasm</code>/<code>.cwasm</code> files are already compiled). <code>./wasmtest.sh fr filelist.txt</code> files, file <code>f</code> Compile and run test files listed in a user-provided text file (each line should contain one <code>.c</code> filename). <code>./wasmtest.sh f filelist.txt</code> <code>--timeout=&lt;seconds&gt;</code> (optional) (none) Set a custom test timeout (in seconds). Default: 5 seconds. <code>./wasmtest.sh single file.c --timeout=10</code>"},{"location":"contribute/unit-tests/#notes","title":"Notes","text":"<ul> <li><code>LIND_WASM_BASE</code>: Defaults to <code>/home/lind/lind-wasm</code>. You can override it:   ```bash   export LIND_WASM_BASE=\"/custom/path/to/lind-wasm\"</li> <li><code>&lt;file&gt;.c</code>: A single test file to compile or run, found in <code>$LIND_WASM_BASE/tests/unit-tests</code>.  </li> <li><code>&lt;filelist&gt;</code>: A text file containing one <code>.c</code> filename per line, found in <code>$LIND_WASM_BASE/tests/unit-tests</code>.  </li> </ul>"},{"location":"contribute/writeDoc/","title":"How to Add Documentation","text":"<p>This doc is using the <code>material</code> for <code>mkdocs</code>, which turns markdown files into an online doc website.</p> <p>You should have <code>mkdocs</code> installed on your terminal first.</p> <p>Do not edit on <code>gh-pages</code> branch, this is updated by github action automatically.</p> <p>To add a new seperate page of documentation, you need to</p> <ol> <li>add a new <code>.md</code> markdown file to the <code>docs/</code> directory</li> <li>in the <code>mkdocs.yml</code> file's <code>nav:</code> section, add a the new page's path</li> <li>IMPORTANT: test if the changes works as expected by running <code>mkdocs serve</code> in the root directory of this repo, only push the changes after checking it works</li> </ol> <p>NOTE: a github action of compiling these markdown files has already been setup. Once the changes of <code>.md</code> files are pushed, the static website branch will be automatically updated shortly.</p>"},{"location":"internal/libc/","title":"Modifications Made to glibc and <code>crt1.c</code>","text":""},{"location":"internal/libc/#1-changes-to-glibc","title":"1. Changes to glibc","text":""},{"location":"internal/libc/#11-changing-the-system-call-mechanism","title":"1.1 Changing the System Call Mechanism","text":"<p>The system call mechanism was modified to route system calls through <code>rawposix</code> instead of directly invoking the kernel. The new format for making system calls is structured as follows:</p> <pre><code>MAKE_SYSCALL(syscallnum, \"syscall|callname\", arg1, arg2, arg3, arg4, arg5, arg6)\n</code></pre> <p>For each system call file in glibc, a header file named <code>syscall-template.h</code> was added with the following content:</p> <pre><code>#include &lt;sys/syscall.h&gt;\n#include &lt;stdint.h&gt;    // For uint64_t\n#include &lt;unistd.h&gt;\n#include &lt;lind_syscall.h&gt;\n\n// Define NOTUSED for unused arguments\n#define NOTUSED 0xdeadbeefdeadbeefULL\n\n// Macro to create a syscall and redirect it to rawposix\n#define MAKE_SYSCALL(syscallnum, callname, arg1, arg2, arg3, arg4, arg5, arg6) \\\n    lind_syscall(syscallnum, \\\n                 (unsigned long long)(callname), \\\n                 (unsigned long long)(arg1), \\\n                 (unsigned long long)(arg2), \\\n                 (unsigned long long)(arg3), \\\n                 (unsigned long long)(arg4), \\\n                 (unsigned long long)(arg5), \\\n                 (unsigned long long)(arg6))\n</code></pre> <p>The <code>MAKE_SYSCALL</code> macro redirects system calls to rawposix, providing an interface for syscall handling in this context.</p>"},{"location":"internal/libc/#12-eliminating-assembly-code","title":"1.2 Eliminating Assembly Code","text":"<p>Since WebAssembly (WASM) does not support assembly, all assembly-related components in glibc were removed: - Inline assembly code was rewritten in C. - Files ending in <code>.s</code> were converted to <code>.c</code> files, and their functionalities were reimplemented in C.</p>"},{"location":"internal/libc/#13-handling-automatically-generated-s-files","title":"1.3 Handling Automatically Generated <code>.s</code> Files","text":"<p>glibc automatically generates <code>.s</code> files for certain system calls. To address this: - The script responsible for generating these <code>.s</code> files was disabled. - The corresponding system calls were manually implemented in C and placed in appropriate <code>.c</code> files.</p>"},{"location":"internal/libc/#14-additional-modifications","title":"1.4 Additional Modifications","text":"<ul> <li>Disable <code>_dl_mcount_wrapper_check</code>: This functionality was disabled as it is not required in the WASI environment.</li> <li>Change <code>initial-exec</code> to <code>local-exec</code>: All instances of <code>initial-exec</code> were replaced with <code>local-exec</code> to align with WebAssembly's threading and memory model.</li> <li>Implement <code>BYTE_COPY_FWD</code> and <code>BYTE_COPY_BWD</code>: These functions were implemented in C without relying on <code>memcpy</code> or <code>memmove</code> to ensure compatibility with the WASM environment.</li> <li>Disable <code>attribute_relro</code>: The original C code places the vtable into the <code>relro</code> section in the binary. Since WebAssembly binaries do not have this section, the attribute was disabled.</li> </ul>"},{"location":"internal/libc/#2-modifications-and-additions-to-crt1c-for-wasi","title":"2. Modifications and Additions to <code>crt1.c</code> for WASI","text":""},{"location":"internal/libc/#21-wasi-specific-function-wrappers","title":"2.1 WASI-Specific Function Wrappers","text":"<ul> <li>Wrappers for WASI Snapshot Preview 1 APIs:   Several wrappers were defined for handling WASI <code>args</code> and <code>environ</code> APIs, including:</li> <li><code>__imported_wasi_snapshot_preview1_args_sizes_get</code></li> <li><code>__imported_wasi_snapshot_preview1_args_get</code></li> <li><code>__imported_wasi_snapshot_preview1_environ_get</code></li> <li> <p><code>__imported_wasi_snapshot_preview1_environ_sizes_get</code></p> </li> <li> <p>Implementation:   These wrappers use the following attribute for integration:   <code>c   __attribute__((       __import_module__(\"wasi_snapshot_preview1\"),       __import_name__(\"function_name\")   ));</code></p> </li> <li> <p>Purpose: Enables access to WASI-specific argument and environment APIs.</p> </li> </ul>"},{"location":"internal/libc/#22-environment-initialization","title":"2.2 Environment Initialization","text":"<ul> <li>Added <code>__wasi_initialize_environ</code>:   This function initializes the environment variables by:</li> <li>Using <code>__wasi_environ_sizes_get</code> to determine the size of environment data.</li> <li> <p>Using <code>__wasi_environ_get</code> to populate the <code>environ</code> array.</p> </li> <li> <p>Fallback Logic:   If the environment is empty, the program:</p> </li> <li>Falls back to a static empty environment (<code>empty_environ</code>).</li> <li>Exits with an appropriate error code when necessary.</li> </ul>"},{"location":"internal/libc/#23-thread-and-tls-setup","title":"2.3 Thread and TLS Setup","text":"<ul> <li>Added Calls to <code>__libc_setup_tls</code> and <code>__wasi_init_tp</code>:   These functions are included in <code>_start</code> to set up thread-local storage (TLS) and thread pointers, which are essential for multithreading or TLS-dependent code.</li> </ul>"},{"location":"internal/libc/#24-main-function-handling","title":"2.4 Main Function Handling","text":"<ul> <li>Modified <code>__main_void</code> to Handle WASI Arguments:</li> <li>Initializes command-line arguments by:<ul> <li>Using <code>__wasi_args_sizes_get</code> to determine argument buffer sizes.</li> <li>Using <code>__wasi_args_get</code> to populate <code>argv</code> and <code>argv_buf</code>.</li> </ul> </li> <li> <p>Passes the initialized arguments to <code>__main_argc_argv</code>.</p> </li> <li> <p>Weak Symbol for <code>__main_argc_argv</code>:   Defined as a weak symbol to allow the dynamic linker to handle cases where no <code>main</code> function exists (e.g., in reactor-style applications).</p> </li> </ul>"},{"location":"internal/libc/#25-error-handling","title":"2.5 Error Handling","text":"<ul> <li>Specific Exit Codes:</li> <li> <p>Introduced <code>_Exit(EX_OSERR)</code> and <code>_Exit(EX_SOFTWARE)</code> for different error scenarios, aligning with <code>sysexits.h</code> standards.</p> </li> <li> <p>Purpose: Provides descriptive and standard error handling for memory allocation or initialization failures.</p> </li> </ul>"},{"location":"internal/libc/#26-placeholder-functions","title":"2.6 Placeholder Functions","text":"<ul> <li>Added Stub for <code>__wasm_call_dtors</code>:</li> <li> <p>An empty placeholder function for future destructor handling.</p> </li> <li> <p>Added Stub for <code>__wasi_proc_exit</code>:</p> </li> <li>A placeholder function for handling process exits in WASI.</li> </ul>"},{"location":"internal/libc/#27-memory-allocation-for-argv-and-environ","title":"2.7 Memory Allocation for <code>argv</code> and <code>environ</code>","text":"<ul> <li>Allocates memory dynamically for:</li> <li>Argument buffers (<code>argv_buf</code>) and pointers (<code>argv</code>).</li> <li>Environment buffers (<code>environ_buf</code>) and pointers (<code>environ_ptrs</code>).</li> <li>Uses <code>malloc</code> and <code>calloc</code> with robust error handling to prevent memory allocation failures.</li> </ul>"},{"location":"internal/multiprocess-support/","title":"Multi-Process Support in Lind-Wasm","text":""},{"location":"internal/multiprocess-support/#multi-processing-via-asyncify","title":"Multi-processing via Asyncify","text":"<p>The way multi-process (specifically clone_syscall, exit_syscall and longjmp) works in lind-wasm heavily depends on Asyncify from Binaryen. So let\u2019s first introduce how Asyncify works on WebAssembly.\\ So Asyncify is a second-time compilation that adds some logic to the existing compiled file.\\ The Asyncify works by having a few global variables that define the current execution status. One global variable is to describe the current status of stack unwind/rewind. If current_state is set to unwind, that means the current process is undergoing stack unwind, and if current_state is set to rewind, that means the current process is undergoing stack rewind, and if current_state is set to normal, that means the current process is working normally, just like no Asyncify has applied to it.\\ \\ For example, suppose there is a program looks like this:</p> <pre><code>int funcA()\n{\n    int a;\n    int b;\n\n    for... {\n        ...do some work...\n    }\n\n    funcB();\n\n    ...do some work...\n}\n\nint funcB()\n{\n    ...do some work\n      imported_wasm_functionC();\n}\n\n</code></pre> <p>After applying Asyncify, it may become something like this:</p> <pre><code>int funcA()\n{\n    if(current_state == rewind) {\n        restore_functionA_context();\n    }\n    if(current_state == normal) {\n        int a;\n        int b;\n\n        for... {\n            ...do some work...\n        }\n    }\n    if(last_unwind_return_is_here)\n    {\n        funcB();\n        if(current_state == unwind) {\n            save_functionA_context();\n            return;\n        }\n    }\n\n    if(current_state == normal) {\n        ...do some work...\n    }\n}\n\nint funcB()\n{\n    if(current_state == rewind) {\n        restore_functionB_context();\n    }\n    if(current_state == normal) {\n        if(current_state == normal) {\n            ...do some work\n        }\n    }\n\n    if(last_unwind_return_is_here) {\n        imported_wasm_functionC();\n        if(current_state == unwind) {\n            save_functionB_context();\n            return;\n        }\n    }\n}\n\n</code></pre> <p>So Asyncify basically adds an if statement for all the normal user code and only executes the user code if current_state is normal. After a function has been executed, it will check if current_state is set to unwind. If that is the case, the function context will be saved and the function will return immediately. When rewind happens later, the function context will be restored at the beginning of the function.\\ \\ Besides these, Asyncify also has four functions that control the global current_state.\\ Asyncify_unwind_start: Once called, set current_state to unwind and return\\ Asyncify_unwind_stop: Once called, set current_state to normal and return\\ Asyncify_rewind_start: Once called, set current_state to rewind and return\\ Asyncify_rewind_stop: Once called, set current_state to normal and return\\ Asyncify_unwind_start and Asyncify_rewind_start also takes an additional argument that specifies where to store/retrieve the unwind_data (i.e. function context).</p> <p>Such transformation from Asyncify allows you to freely navigate the callstack of a process, but with the cost of largely increased binary size, and slightly decreased performance (from a bunch of extra if statements added by Asyncify).</p>"},{"location":"internal/multiprocess-support/#fork","title":"fork()","text":"<p>The fork syscall is built up on Asyncify. When fork is called, the whole wasm process would undergo unwind and rewind. But the unwind_data (function context) is copied once unwind is done. The unwind_data could basically be viewed as a snapshot of the callstack (with the unwind_data, we can restore the wasm process to the state when unwind_data is captured). With such a powerful mechanism, the implementation of the fork is pretty straightforward: once we capture the snapshot of the parent process callstack, we can let the child do the rewind with the unwind_data from parent, and the child will be able to return to the exact state when parent calls fork. Threading creation is very similar to this, except that the memory is shared between parent and child.</p>"},{"location":"internal/multiprocess-support/#exit-and-exec","title":"exit() and exec()","text":"<p>Exit syscall is currently also built on Asyncify, by performing the unwind on the process, then instead of doing rewinding, the process can just return.</p> <p>Exec syscall is built upon Exit syscall: instead of returning directly after unwind is finished, a new wasm instance is created with the supplied binary path.</p>"},{"location":"internal/multiprocess-support/#setjmp-and-longjmp","title":"setjmp() and longjmp()","text":"<p>Setjmp and longjmp implementation is also very similar to fork: When setjmp is called, the process will undergo unwind and rewind, leaving an unwind_data (callstack snapshot). The unwind_data is saved somewhere. When later the process calls longjmp and specifies a restore to the previous state, the process first will unwind, after unwind is finished, its unwind_data will be replaced by the old unwind_data generated when setjmp is called. Then after rewind, the process can restore to its previous state. </p>"},{"location":"internal/multiprocess-support/#wait","title":"wait()","text":"<p>Last we have our wait_syscall which is implemented purely in rawposix and does not use Asyncify at all. Wait_syscall works by maintaining a zombie relationship in the cage struct: when a cage exits, it will insert itself into the parent\u2019s zombie list. Therefore, the parent can simply check its zombie list when doing the wait syscall, and retrieve the first zombie in the list (first in first out).</p>"},{"location":"internal/rawposix/","title":"Introduction","text":""},{"location":"internal/rawposix/#overview-of-rawposix","title":"Overview of RawPOSIX","text":"<p>RawPOSIX is a critical component of the Lind Project, designed to provide a POSIX-compliant interface for applications running within a microvisor environment. The primary goal of RawPOSIX is to enable the execution of both legacy and modern multi-processes\u2019 applications safely and efficiently within the same address space without any modification to source code and perform the same behavior with applications running on native Linux.</p>"},{"location":"internal/rawposix/#purpose-and-scope-of-rawposix","title":"Purpose and Scope of RawPOSIX","text":"<p>The purpose of the RawPOSIX project is to provide an in-process OS while isolating them. By offering a POSIX-like interface, RawPOSIX is an interface implemented on top of standard POSIX (Linux) system calls. It provides functionalities such as signals, fork/exec, threading, file system operations, and networking. Additionally, RawPOSIX manages file descriptors (FDs), threads, and other resources independently for each cage, ensuring proper isolation and resource handling. This is particularly beneficial for legacy applications that rely on POSIX standards.</p> <p>The scope of RawPOSIX encompasses several key areas: - System Call API: Implementing a set of raw POSIX system calls that redirect low level operations to kernel and a set of userspace system calls based on POSIX standard to cover process management, network operations, and memory management. - Cage Structure: A \"cage\" data structure in RawPOSIX is designed to handle per-process information while providing required memory management. - Testing and Validation: Providing a testing framework to ensure the reliability and correctness of the RawPOSIX implementation.</p>"},{"location":"internal/rawposix/#key-components-and-files","title":"Key Components and Files","text":"<p>The RawPOSIX repository is organized into several important folders and files that contribute to its functionality: - src/: This directory contains the main Rust codebase for RawPOSIX. It includes the implementation of the syscall API and other core components. - syscalls.rs: This file defines the various system calls supported by RawPOSIX, implementing the logic for each operation. - cage.rs: This file contains definitions of the Cage data structure as well as functions of corresponding operations like creation / insertion / etc. and life cycle management of cages. - tests/: This directory includes test cases and scripts to validate the functionality of RawPOSIX. It ensures that all system calls and cage operations work as expected. - docs/: Documentation files that provide additional context and instructions for setting up and using RawPOSIX.</p>"},{"location":"internal/rawposix/#syscall-api","title":"Syscall API","text":""},{"location":"internal/rawposix/#supported-system-calls","title":"Supported System Calls","text":"<p>In RawPOSIX, raw syscalls are used for direct interactions with the Linux kernel to handle low-level operations, while userspace syscalls serve as abstractions tailored to manage runtime-specific needs (e.g., WASM or Native Client) and ensure isolation through features like per-cage memory management and multi-processing support.</p> <p>For standard system calls, RawPOSIX primarily processes variables passed from the runtime environment and redirects them to the Linux kernel. Beyond supporting standard POSIX system calls (e.g., file system and networking calls), RawPOSIX implements additional features, including: - Memory Management: RawPOSIX provides memory management tailored to the runtime environment, leveraging VMMap-related system calls to enable per-cage memory management. - Process Management: Functions such as wait, waitpid, fork, exec, and signal handling are implemented to support multi-processing. These functions update the cage structure and corresponding data structures as needed, ensuring proper isolation and accurately reflecting the state of processes.</p>"},{"location":"internal/rawposix/#testing","title":"Testing","text":"<p>RawPOSIX employs a comprehensive testing framework to validate its functionality and ensure that all components operate as expected. The testing framework is designed to cover scenarios including both normal usage and error returns. Tests can be found on: lind-wasm/src/RawPOSIX/src/tests/</p>"},{"location":"internal/wasmtime/","title":"Introduction to Wasmtime","text":""},{"location":"internal/wasmtime/#what-is-wasmtime","title":"What is Wasmtime?","text":"<p>Wasmtime is a standalone JIT-style runtime for WebAssembly, designed for use with WebAssembly System Interface (WASI) and other WASI-inspired environments. It is part of the Bytecode Alliance, an open-source effort to create secure software foundations.</p> <p>Wasmtime can run WebAssembly modules that follow the WASI standard, providing a robust and efficient environment for running WebAssembly outside of the browser.</p>"},{"location":"internal/wasmtime/#getting-started-with-wasmtime","title":"Getting Started with Wasmtime","text":"<p>To get started with Wasmtime, you can download and install it from the official Wasmtime releases page. Follow the installation instructions specific to your operating system.</p>"},{"location":"use/compile-programs/","title":"Compile Programs","text":""},{"location":"use/compile-programs/#compiling-a-webassembly-module-with-clang","title":"Compiling a WebAssembly Module with Clang","text":"<p>Let's start with a simple example, <code>malloc-test.c</code>, which demonstrates dynamic memory allocation using <code>malloc</code> in C. We will compile this C program to a WebAssembly module using Clang with the WASI target.</p>"},{"location":"use/compile-programs/#example-c-program-malloc-testc","title":"Example C Program: <code>malloc-test.c</code>","text":"<pre><code>#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    const char *str = \"Hello from Dennis's WASM!\\n\";\n\n    size_t str_len = strlen(str) + 1;\n\n    char *buf = malloc(str_len);\n\n    if (buf == NULL) {\n        return -1;\n    }\n\n    strcpy(buf, str);\n\n    write(1, buf, str_len - 1);\n\n    free(buf);\n\n    return 0;\n}\n</code></pre>"},{"location":"use/compile-programs/#compiling-the-program","title":"Compiling the Program","text":"<p>Use the following command to compile the <code>malloc-test.c</code> program to WebAssembly:</p> <pre><code>../../clang+llvm-16.0.4-x86_64-linux-gnu-ubuntu-22.04/bin/clang-16 --target=wasm32-unknown-wasi --sysroot /home/dennis/Documents/Just-One-Turtle/wasi-libc/sysroot malloc-test.c -g -O0 -o malloc-test.wasm\n</code></pre> <ul> <li><code>--target=wasm32-unknown-wasi</code>: Specifies the target to be WebAssembly with WASI.</li> <li><code>--sysroot /home/dennis/Documents/Just-One-Turtle/wasi-libc/sysroot</code>: Points to the WASI sysroot directory.</li> <li><code>-g</code>: Includes debugging information.</li> <li><code>-O0</code>: Disables optimizations for easier debugging.</li> </ul>"},{"location":"use/compile-programs/#frequently-used-flags","title":"Frequently Used Flags","text":"<ul> <li><code>--target=wasm32-unknown-wasi</code> for compiling to wasm</li> <li><code>-c</code> for compiling as a library without main executable</li> <li><code>-pthread</code> then the compiler to understand <code>__tls_base</code> etc</li> <li><code>--sysroot</code> specifying the stand library path</li> </ul>"},{"location":"use/compile-programs/#modify-stubsh","title":"Modify stubs.h","text":"<p>Modify the file <code>stubs.h</code> located in <code>/home/lind-wasm/glibc/target/include/gnu</code> to</p> <pre><code>/* This file is automatically generated.\n   This file selects the right generated file of `__stub_FUNCTION' macros\n   based on the architecture being compiled for.  */\n\n\n//#if !defined __x86_64__\n//# include &lt;gnu/stubs-32.h&gt;\n//#endif\n#if defined __x86_64__ &amp;&amp; defined __LP64__\n# include &lt;gnu/stubs-64.h&gt;\n#endif\n#if defined __x86_64__ &amp;&amp; defined __ILP32__\n# include &lt;gnu/stubs-x32.h&gt;\n#endif\n</code></pre> <p>After modifying <code>stubs.h</code> remember to run <code>gen_sysroot.sh</code> again</p> <pre><code>cd /home/lind-wasm/glibc\n./gen_sysroot.sh\n</code></pre> <p>Then we cd to lind-wasm-tests for testing</p> <pre><code>cd /home/lind-wasm/lind-wasm-tests\n</code></pre>"},{"location":"use/compile-programs/#compile-c-to-wasm","title":"Compile C to wasm","text":"<p>If you don't need to use glibc, modify <code>add.c</code> to the c file you want to compile and <code>add.wasm</code> is the wasm file you get(you can modify add to the name you want). Modify <code>/home/clang+llvm-16.0.4-x86_64-linux-gnu-ubuntu-22.04/bin/clang</code> to you compiler's path</p> <pre><code>/home/clang+llvm-16.0.4-x86_64-linux-gnu-ubuntu-22.04/bin/clang --target=wasm32 -nostdlib -Wl,--no-entry -Wl,--export-all -o add.wasm add.c\n</code></pre> <p>If you need to use glibc(such as printf, printf.c is located in lind-wasm/lind-wasm-tests), modify <code>printf.c</code> to the c file you want to compile and <code>printf.wasm</code> is the wasm file you get(you can modify printf to the name you want). Modify <code>/home/clang+llvm-16.0.4-x86_64-linux-gnu-ubuntu-22.04/bin/clang-16</code> to you compiler's path</p> <pre><code>/home/clang+llvm-16.0.4-x86_64-linux-gnu-ubuntu-22.04/bin/clang --target=wasm32-unknown-wasi --sysroot /home/lind-wasm/glibc/sysroot printf.c -g -O0 -o printf.wasm\n</code></pre> <p>You should get printf.wasm after compiling printf.c</p>"},{"location":"use/debug-programs/","title":"Debugging with GDB","text":"<p>To debug the WebAssembly module, you can use GDB with Wasmtime. Ensure that you have compiled the module with the <code>-g</code> flag to include debugging information.</p> <p>NOTE: currently this debugging tool does not support inspecting instructions. And operations like <code>layout split</code> and <code>si</code> might break the terminal. Using <code>layout src</code> is recommended.</p>"},{"location":"use/debug-programs/#running-gdb-with-wasmtime","title":"Running GDB with Wasmtime","text":"<p>Use the following command to run GDB with Wasmtime:</p> <pre><code>gdb --args ../wasmtime/target/debug/wasmtime run -D debug-info -O opt-level=0 malloc-test.wasm\n</code></pre> <ul> <li><code>gdb --args</code>: Passes the arguments to GDB.</li> <li><code>../wasmtime/target/debug/wasmtime run</code>: Specifies the Wasmtime executable.</li> <li><code>-D debug-info</code>: Enables debugging information.</li> <li><code>-O opt-level=0</code>: Sets the optimization level to 0 for debugging.</li> </ul>"},{"location":"use/debug-programs/#example-debugging-session","title":"Example Debugging Session","text":"<ol> <li> <p>Start GDB:    <code>sh    gdb --args ../wasmtime/target/debug/wasmtime run -D debug-info -O opt-level=0 malloc-test.wasm</code></p> </li> <li> <p>Set Breakpoints:    In the GDB prompt, set breakpoints as needed, for example:    <code>sh    (gdb) break main</code></p> </li> <li> <p>Run the Program:    Start the execution of the WebAssembly module:    <code>sh    (gdb) run</code></p> </li> <li> <p>Inspect and Debug:    Use GDB commands to inspect variables, step through the code, and debug your program:    <code>sh    (gdb) next    (gdb) print p    (gdb) continue</code></p> </li> </ol> <p>By following these steps, you can compile, run, and debug WebAssembly modules using Wasmtime and GDB. This provides a powerful environment for developing and debugging WebAssembly applications.</p> <p>For more details, refer to the official Wasmtime documentation and the GDB documentation.</p>"},{"location":"use/examples/","title":"Examples of Compiling and Running","text":""},{"location":"use/examples/#hello-world","title":"Hello, World!","text":"<p>To begin, a simple \"Hello World\" file can be created.  In this case, as follows:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n\n</code></pre> <p>First, it can be compiled and run as usual with native gcc:</p> <pre><code>gcc hello.c -o hello\n./hello\n</code></pre> <p>Then under lind, where it should produce the same output:</p> <pre><code>./lindtool.sh cptest hello\n./lindtool.sh run hello\n</code></pre>"},{"location":"use/examples/#example-with-header-file-included","title":"Example with Header file included","text":"<p>Header files can be included in the same way.  Below is a simplified example:</p>"},{"location":"use/examples/#print_ith","title":"<code>print_it.h</code>:","text":"<pre><code>#ifndef PRINT_IT_H\n#define PRINT_IT_H\n\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\nstatic inline void print_it(const char *message) {    \n    time_t now = time(NULL);\n    struct tm *t = localtime(&amp;now);char timestamp[20];\n    strftime(timestamp, sizeof(timestamp), \"%Y-%m-%dT%H:%M:%S\", t);\n    printf(\"%s %s\\n\", timestamp, message);\n}\n\n#endif\n</code></pre>"},{"location":"use/examples/#helloworldc","title":"<code>helloworld.c</code>:","text":"<pre><code>#include \"print_it.h\"\n\nint main() {\n    print_it(\"Hello, World!\");\n    return 0;\n}\n\n</code></pre> <p>Again, it can be compiled and run as usual with native gcc:</p> <pre><code>gcc helloworld.c -o helloworld\n./helloworld\n</code></pre> <p>Then under lind, where it should produce the same output:</p> <pre><code>./lindtool.sh cptest helloworld\n./lindtool.sh run helloworld\n</code></pre>"},{"location":"use/run-programs/","title":"Run Programs","text":""},{"location":"use/run-programs/#run-wasmtime","title":"Run wasmtime","text":"<p>Run the <code>.wasm</code> file, modify the wasmtime path to your own</p> <pre><code>/home/lind-wasm/wasmtime/target/debug/wasmtime add.wasm\n</code></pre> <p>For printf.wasm, you should get <code>Hello World!</code>.</p> <p>Now let try to print <code>hello world!</code> by printf</p> <pre><code>./lindtool.sh cptest PATH_TO_TEST\n./lindtool.sh run PATH_TO_TEST\n</code></pre>"},{"location":"use/run-programs/#running-the-webassembly-module-with-wasmtime","title":"Running the WebAssembly Module with Wasmtime","text":"<p>After compiling the WebAssembly module, you can run it using Wasmtime:</p> <pre><code>../wasmtime/target/debug/wasmtime run malloc-test.wasm\n</code></pre>"}]}